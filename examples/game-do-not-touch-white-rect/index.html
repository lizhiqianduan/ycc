<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>游戏-别踩白块</title>
	<link rel="stylesheet" href="../style.css">
	<style>
		body{
			font-size: 0;
			position: relative;
		}

	</style>
</head>
<body>
<div class="score">分数： <span id="score-number">0</span></div>
</body>
</html>

<script src="../common.js"></script>
<script src="../../build/ycc.js"></script>


<script>
	var canvas = document.createElement('canvas');
	console.log(document.documentElement.clientWidth,document.documentElement.clientHeight);
	canvas.width=document.documentElement.clientWidth;
	canvas.height=document.documentElement.clientHeight;
	document.body.appendChild(canvas);



	var ycc = new Ycc().bindCanvas(canvas);
	var stageW = ycc.getStageWidth();
	var stageH = ycc.getStageHeight();
	// 所有的资源
	var images = null;
	// 当前场景
	var currentScene = null;


	// 加载图片资源
	ycc.loader.loadImgOneByOne([
		{name:"start",url:"./images/start.png"},
		{name:"restart",url:"./images/restart.png"},
	],function (imgs) {
		console.log(imgs,222);
		images = imgs;
		currentScene = new StartScene();
		ycc.layerManager.reRenderAllLayerToStage();
	});




	// 开启动画，每帧都更新场景
	ycc.ticker.start(60);
	ycc.ticker.addFrameListener(function () {
		currentScene && currentScene.update && currentScene.update();
		ycc.layerManager.reRenderAllLayerToStage();
	});









	function StartScene(){
		var self = this;

		this.layer = ycc.layerManager.newLayer({enableEventManager:true});

		this.layer.addUI(new Ycc.UI.Image({
			rect:new Ycc.Math.Rect(stageW/2-images.start.naturalWidth/2,stageH/2-images.start.naturalHeight/2,images.start.naturalWidth,images.start.naturalHeight),
			res:images.start,
			ontap:function (e) {
				self.delSelf();
				currentScene = new GameScene();
			}
		}));
	}

	/**
	 * 删除自身
	 */
	StartScene.prototype.delSelf = function () {
		ycc.layerManager.deleteLayer(this.layer);
	};


	function GameScene(){
		this.layer = ycc.layerManager.newLayer({enableEventManager:true});

		// 四列
		this.col = 4;
		// 五行
		this.row = 3;

		// y轴总的偏移量
		this.offsetY = 0;

		// 每帧Y轴的步长
		this.spaceY = 50;

		// 方框宽度
		this.rectW = parseInt(stageW/this.col);

		// 方框高度
		this.rectH = parseInt(stageH/this.row);

		// 初始时所有方块可能的y值
		this.rectYList = [];

		// 已偏移的方块个数
		this.offsetNumber=-1;

		// 矩阵
		this.M = new Ycc.Math.Matrix([],this.row,this.col);

		this.colLines = [];

		this.rowLines = [];

		this.rects = [];

		// 初始值
		this.M.set(1,2,1);
		this.M.set(2,3,1);
		this.M.set(3,1,1);
		this.M.set(4,4,1);
		this.M.set(5,2,1);


		this.createRect();
		this.createColLine();
		this.createRowLine();

	}

	// 添加竖线
	GameScene.prototype.createColLine = function () {
		for(var i=0;i<this.col;i++){
			var x = (this.rectW*i);
			var line = new Ycc.UI.Line({
				color:'white',
				start:new Ycc.Math.Dot(x,0),
				end:new Ycc.Math.Dot(x,stageH)
			});
			this.colLines.push(line);
			this.layer.addUI(line);
		}
	};
	// 画横线
	GameScene.prototype.createRowLine = function () {
		for(var i=-2;i<this.row+2;i++){
			var y = (this.rectH*i);
			var line = new Ycc.UI.Line({
				color:'white',
				start:new Ycc.Math.Dot(0,y),
				end:new Ycc.Math.Dot(stageW,y)
			});
			this.rowLines.push(line);
			this.layer.addUI(line);
		}
	};

	// 创建方块
	GameScene.prototype.createRect = function () {
		var self = this;
		for(var i=-2;i<this.row+1;i++){
			for(var j=0;j<this.col;j++){
				var x = (this.rectW*j);
				var y = (this.rectH*i);
				if(this.rectYList.indexOf(y)===-1)
					this.rectYList.push(y);
				var rect = new Ycc.UI.Rect({
					rect:new Ycc.Math.Rect(x,y,this.rectW,this.rectH),
					color:(this.M.get(i+1,j+1)===1)?'white':'black',
					ontap:function (e) {
						self.rectOnTap(e);
					}
				});
				this.rects.push(rect);
				this.layer.addUI(rect);

			}
		}
	};

	// 每个方块的点击事件
	GameScene.prototype.rectOnTap = function (e) {
		console.log(this,e);

		if(e.target.color==="white"){
			e.target.color="red";
		}
	};


	GameScene.prototype.update = function () {
		var i=0,j=0;
		this.offsetY+=this.spaceY;
		if(this.offsetNumber!==parseInt(this.offsetY/this.rectH)){
			this.offsetNumber=parseInt(this.offsetY/(this.rectH));
			console.log('偏移个数-->',this.offsetNumber);

			// 所有横线减去一个方块的偏移量
			for(j=0;j<this.rowLines.length;j++){
				this.rowLines[j].start.y-=this.rectH;
				this.rowLines[j].end.y-=this.rectH;
			}

			// 方块的总行数
			var rectRow = this.rects.length/this.col;
			console.log();

			var rowIndex=rectRow-(this.offsetNumber)%rectRow-1;

			// 将最末一行方块的坐标更改至最上方，并随机修改其颜色
			for(i=0;i<this.col;i++){
				var rect = this.rects[(rowIndex)*this.col+i];
				var before = rect.rect.y;
				rect.rect.y = before-(rectRow)*this.rectH;
				rect.color=Math.random()>0.2?"black":"white";
//				console.log('方块的总行数-->',rectRow,'需要变化的行下标-->',rowIndex,'更改前的y-->',before,'更改后的y-->',rect.y);
			}
		}


		for(i=0;i<this.rects.length;i++){
			this.rects[i].rect.y+=this.spaceY;
		}

		for(j=0;j<this.rowLines.length;j++){
			this.rowLines[j].start.y+=this.spaceY;
			this.rowLines[j].end.y+=this.spaceY;
		}

	};



</script>


